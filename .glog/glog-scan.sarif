{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-ab61403a-c772-4daf-b5bc-8046be1aface",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `shell=True` subprocess call security vulnerability in Python occurs when a developer uses the `shell=True` argument in the `subprocess` module's methods. This can lead to shell injection attacks if the command string that is passed is constructed using unsanitized input from an untrusted source.\n\nThe `subprocess` module allows you to spawn new processes, connect to their input/output/error pipes, and obtain their return codes. When `shell=True` is used, the specified command is executed through the shell. This can be a security hazard if combined with untrusted input as it allows for shell injection, a form of command injection attack where an attacker can execute arbitrary commands in the system's shell.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `shell=True` in your `subprocess` calls, especially if you're using user-provided or otherwise externally-provided input to form your command string. If you must use `shell=True`, make sure to properly sanitize and escape all input.\n\n## Source Code Fix Recommendation\n\nInstead of using `shell=True`, you can pass the command and its arguments as a list. Here's an example:\n\n```python\n# Vulnerable code\nimport subprocess\ncommand = \"ls -l\"\nsubprocess.call(command, shell=True)\n\n# Recommended fix\nimport subprocess\ncommand = [\"ls\", \"-l\"]\nsubprocess.call(command)\n```\n\nIn the fixed code, the command and its arguments are passed as a list, and `shell=True` is not used. This way, even if an attacker can control some part of the command string, they cannot inject arbitrary commands.\n\n## References\n\n- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "tags": [
                  "B602"
                ]
              }
            },
            {
              "id": "glog-16e48097-92fe-4d3a-ba06-732f6e407b95",
              "help": {
                "text": "",
                "markdown": "## Description\n\nSQL Injection Vulnerability via String-Based Query Construction is a common security vulnerability in applications that use an SQL database. It occurs when an application uses input to construct an SQL query without properly sanitizing or escaping it. This allows an attacker to manipulate the query to execute arbitrary SQL commands, which can lead to unauthorized access, data corruption, or data loss.\n\nIn Python, this vulnerability often occurs when using the `format` function or string concatenation to construct SQL queries. This is because these methods do not automatically escape special characters in the input, which can be used to alter the structure of the query.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should never construct SQL queries using string formatting or concatenation with unsanitized input. Instead, use parameterized queries or prepared statements, which automatically sanitize input and prevent SQL injection.\n\nIf you must use string formatting to construct SQL queries, make sure to properly sanitize the input. This can be done using the `escape` function from the `mysql.connector` module, or the `quote` function from the `psycopg2` module, depending on the SQL database you are using.\n\n## Source Code Fix Recommendation\n\nHere is an example of a vulnerable code snippet and how to fix it:\n\n**Vulnerable Code:**\n\n```python\ndef update_user(username, email):\n    query = \"UPDATE users SET email = '{}' WHERE username = '{}'\".format(email, username)\n    cursor.execute(query)\n```\n\n**Fixed Code:**\n\n```python\ndef update_user(username, email):\n    query = \"UPDATE users SET email = %s WHERE username = %s\"\n    cursor.execute(query, (email, username))\n```\n\nIn the fixed code, we use a parameterized query to automatically sanitize the `email` and `username` inputs. This prevents an attacker from manipulating the query to execute arbitrary SQL commands.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- An SQL connector library, such as `mysql-connector-python` or `psycopg2`, to connect to the SQL database and execute queries.\n\n## References\n\n- [OWASP Python Security - SQL Injection](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "tags": [
                  "B608"
                ]
              }
            },
            {
              "id": "glog-f6dbf333-97e1-4884-a2e9-9c6d92e5e6ec",
              "help": {
                "text": "",
                "markdown": "## Description\n\nSQL Injection Vulnerability via String-Based Query Construction is a common security vulnerability in applications that use an SQL database. It occurs when an application uses input to construct an SQL query without properly sanitizing or escaping it. This allows an attacker to manipulate the query, potentially gaining unauthorized access to data, modifying data, or executing commands on the database server.\n\nIn Python, this vulnerability often occurs when using the `execute` method of a database cursor with a query string that includes unsanitized input. For example:\n\n```python\ncursor.execute(\"SELECT * FROM dlm_table WHERE column = '%s'\" % variable)\n```\n\nIn this case, if `variable` includes certain special characters (such as a single quote), it can be used to modify the query.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, never construct SQL queries using string formatting with unsanitized input. Instead, use parameterized queries, which can ensure that input is properly escaped, preventing SQL injection attacks.\n\nMost Python database libraries support parameterized queries. For example, in the `sqlite3` library, you can use `?` as a placeholder for parameters:\n\n```python\ncursor.execute(\"SELECT * FROM dlm_table WHERE column = ?\", (variable,))\n```\n\nIn this case, `variable` will be properly escaped, and cannot be used to modify the query.\n\n## Source Code Fix Recommendation\n\nAssuming the original vulnerable code is:\n\n```python\ncursor.execute(\"SELECT * FROM dlm_table WHERE column = '%s'\" % variable)\n```\n\nThe fixed code using parameterized queries would be:\n\n```python\ncursor.execute(\"SELECT * FROM dlm_table WHERE column = ?\", (variable,))\n```\n\n## Library Dependencies\n\nThe code example requires a Python SQL database library that provides a cursor object with an `execute` method. This could be `sqlite3`, `psycopg2`, `mysql-connector-python`, or another similar library.\n\n## References\n\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "tags": [
                  "B608"
                ]
              }
            },
            {
              "id": "glog-113fb92e-cf17-489c-bbf4-7f104686cece",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `shell=True` in the subprocess module of Python is a security vulnerability. When using `shell=True`, the specified command is executed through the shell. This can be a security hazard if combined with untrusted input as it allows for shell injection, a form of command injection attack where an attacker can execute arbitrary commands on the host's shell.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `shell=True` whenever possible, especially if the command string is constructed using external input. Instead, use `shell=False` and pass the command and its arguments as a list.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```python\nimport subprocess\n\ncommand = ['command', 'arg1', 'arg2']\nproc = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=False, universal_newlines=True, bufsize=1)\n```\n\nIn this version, the command and its arguments are passed as a list and `shell=False` is used.\n\n## Library Dependencies\n\nThe code example requires the `subprocess` module, which is part of the Python Standard Library, so no additional library dependencies are needed.\n\n## References\n\n- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "tags": [
                  "B602"
                ]
              }
            },
            {
              "id": "glog-ad9e67d9-98bf-4554-88c6-759f813e2693",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `Shell=True` subprocess call security vulnerability in Python refers to the potential security risk when using the `subprocess` module with `shell=True` parameter. This vulnerability can lead to shell injection attacks where an attacker can execute arbitrary commands on the system by manipulating the input.\n\nThe `subprocess.run()` function is used to run a new subprocess and wait for its completion. When `shell=True` is used, the specified command is executed through the shell. This can be dangerous if combined with unsanitized user input, as it allows for shell injection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `shell=True` whenever possible, especially when the command string involves user input. Instead, use `shell=False` and pass the command and its arguments as a list. This way, the arguments are not processed by the shell, but are passed directly to the program.\n\nIf you must use `shell=True`, make sure to properly sanitize and escape all user input. Be aware that proper escaping can be complex and error-prone, so it's generally better to avoid `shell=True` if at all possible.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```python\nsubprocess.run(commandstring, shell=True, check=True, executable=\"/bin/bash\")\n```\n\nUse:\n\n```python\nsubprocess.run(['command', 'arg1', 'arg2'], check=True)\n```\n\nReplace `'command'`, `'arg1'`, `'arg2'` with your actual command and arguments.\n\n## Library Dependencies\n\nThe code example requires the `subprocess` module, which is part of the Python Standard Library, so no additional library dependencies are needed.\n\n## References\n\n- [OWASP Python Security - Shell Injection](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "tags": [
                  "B602"
                ]
              }
            },
            {
              "id": "glog-eee2b7af-c788-40d9-87a2-99813830f994",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `subprocess.run()` function in Python is used to run new applications or programs through Python code. When the `shell=True` argument is used, it specifies that the command will be executed through the shell. This can lead to a security vulnerability if the command string is constructed using unsanitized input from an untrusted source. This is because the shell can execute arbitrary commands, potentially leading to command injection attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `shell=True` in `subprocess.run()` whenever possible. If you must use it, ensure that the command string is not constructed from unsanitized user input. Instead, use static strings or sanitize the user input before using it to construct the command string.\n\n## Source Code Fix Recommendation\n\nInstead of using `shell=True`, you can pass the command and its arguments as a list. This way, the command is executed directly without going through the shell, thus avoiding the possibility of command injection. Here's how you can modify the code:\n\n```python\nimport subprocess\n\ncommand = [\"/bin/bash\", \"-c\", \"your_command_here\"]\nsubprocess.run(command, check=True)\n```\n\n## Library Dependencies\n\nThe code example requires the `subprocess` module, which is part of the Python Standard Library. Therefore, no additional library dependencies are required.\n\n## References\n\n- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "tags": [
                  "B602"
                ]
              }
            },
            {
              "id": "glog-bdcb1a80-10fe-45e4-a3c4-ac9e959a982c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `subprocess.run()` function in Python is used to run new applications or programs through Python code. When the `shell=True` argument is used, it specifies that the command will be executed through the shell. This can lead to a security vulnerability if the command string is constructed using unsanitized input from an untrusted source. This is because the shell can execute arbitrary commands, potentially leading to command injection attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `shell=True` in `subprocess.run()` whenever possible. If you must use it, ensure that the command string is not constructed from unsanitized user input. Instead, use static strings or sanitize the user input before using it to construct the command string.\n\n## Source Code Fix Recommendation\n\nInstead of using `shell=True`, you can pass the command and its arguments as a list. This way, the command is executed directly without going through the shell, thus avoiding the possibility of command injection. Here's how you can modify the code:\n\n```python\nimport subprocess\n\ncommand = [\"/bin/bash\", \"-c\", \"your_command_here\"]\nsubprocess.run(command, check=True)\n```\n\n## Library Dependencies\n\nThe code example requires the `subprocess` module, which is part of the Python Standard Library. Therefore, no additional library dependencies are required.\n\n## References\n\n- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "tags": [
                  "B602"
                ]
              }
            },
            {
              "id": "glog-432f64f2-5069-47f9-8b07-21a5b8a2cfbf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nSQL Injection Vulnerability via String-Based Query Construction is a common security vulnerability in applications that use an SQL database. It occurs when an application uses user input to construct SQL queries without properly sanitizing the input. This allows an attacker to manipulate the SQL query to perform unauthorized actions, such as viewing, modifying, or deleting data.\n\nIn Python, this vulnerability often occurs when using the `execute` method of a cursor object to execute an SQL query that includes user input. If the user input is included in the query string without being properly sanitized, an attacker can include SQL commands in the input that alter the query's behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, never construct SQL queries using string formatting or concatenation with unsanitized user input. Instead, use parameterized queries or prepared statements, which can ensure that user input is properly sanitized and cannot alter the SQL query's structure.\n\n## Source Code Fix Recommendation\n\nHere is an example of vulnerable code and how to fix it:\n\n**Vulnerable Code:**\n\n```python\ndef get_user(username):\n    cursor.execute(f\"SELECT * FROM users WHERE username = '{username}'\")\n    return cursor.fetchone()\n```\n\n**Fixed Code:**\n\n```python\ndef get_user(username):\n    cursor.execute(\"SELECT * FROM users WHERE username = %s\", (username,))\n    return cursor.fetchone()\n```\n\nIn the fixed code, the SQL query is defined using a placeholder (`%s`), and the user input is passed as a second argument to the `execute` method. This ensures that the user input is properly sanitized and cannot alter the structure of the SQL query.\n\n## Library Dependencies\n\nThe code example requires the `mysql-connector-python` library to connect to a MySQL database and execute SQL queries.\n\n## References\n\n- [OWASP Python Security - SQL Injection](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "tags": [
                  "B608"
                ]
              }
            },
            {
              "id": "glog-980ad1cc-f349-4f81-abdb-8ee3b924a59e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nSQL Injection Vulnerability via String-Based Query Construction is a common security vulnerability in applications that use an SQL database. It occurs when an application uses user input to construct SQL queries without properly sanitizing the input. This allows an attacker to manipulate the SQL query to perform unauthorized actions, such as viewing, modifying, or deleting data.\n\nIn Python, this vulnerability often occurs when using the `format` function or string concatenation to construct SQL queries. This allows an attacker to inject malicious SQL code by providing specially crafted input.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, never use string formatting or concatenation to construct SQL queries. Instead, use parameterized queries or prepared statements, which can ensure that user input is properly sanitized and cannot be used to inject malicious SQL code.\n\n## Source Code Fix Recommendation\n\nHere is an example of vulnerable code and how to fix it:\n\n**Vulnerable Code:**\n\n```python\ndef get_user(username):\n    query = \"SELECT * FROM users WHERE username = '{}'\".format(username)\n    cursor.execute(query)\n```\n\n**Fixed Code:**\n\n```python\ndef get_user(username):\n    query = \"SELECT * FROM users WHERE username = %s\"\n    cursor.execute(query, (username,))\n```\n\nIn the fixed code, we use a parameterized query to ensure that the `username` input is properly sanitized.\n\n## Library Dependencies\n\nThe code example requires the `psycopg2` library to interact with a PostgreSQL database.\n\n```bash\npip install psycopg2\n```\n\n## References\n\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "tags": [
                  "B608"
                ]
              }
            },
            {
              "id": "glog-8f506d5f-a59a-4d6a-9ed5-08e67f577297",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Auto-trust of Unknown Host Key in Paramiko Call\" vulnerability in Python programming language refers to a security flaw where the SSH client automatically trusts and adds an unknown host key to its list of known hosts. This happens when the `AutoAddPolicy()` method from the Paramiko library is used. This can lead to Man-in-the-Middle (MitM) attacks, where an attacker can intercept and possibly alter the communication between the client and the server.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using `AutoAddPolicy()`. Instead, use `RejectPolicy()` or `WarningPolicy()`. The former will reject unknown hosts, while the latter will issue a warning and reject the connection. It's also a good practice to manually manage your known hosts file and verify host keys before adding them.\n\n## Source Code Fix Recommendation\n\nReplace:\n\n```python\nssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n```\n\nWith:\n\n```python\nssh_client.set_missing_host_key_policy(paramiko.RejectPolicy())\n```\n\nOr:\n\n```python\nssh_client.set_missing_host_key_policy(paramiko.WarningPolicy())\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- Paramiko\n\n## References\n\n- [OWASP - Insecure Network Communication](https://owasp.org/www-project-mobile-top-10/2016-risks/m3-insecure-communication)\n- [CWE-295: Improper Certificate Validation](https://cwe.mitre.org/data/definitions/295.html)"
              },
              "properties": {
                "tags": [
                  "B507"
                ]
              }
            },
            {
              "id": "glog-dc03b5b1-edbf-4d16-b583-f47842091177",
              "help": {
                "text": "",
                "markdown": "## Description\n\nPotential Shell Injection through Paramiko Call is a vulnerability that occurs when an application provides an attacker the ability to control the argument to a system call that is made to the Paramiko library. This vulnerability can allow an attacker to execute arbitrary commands on the system with the privileges of the vulnerable application.\n\nIn the provided code snippet, the argument to the `exec_command` function is a static string `\"pwd\"`. However, if this argument is constructed using externally controlled input, then an attacker could potentially inject arbitrary commands.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using user-controlled input to construct system commands. If it is necessary to use user-controlled input in a system command, then the input should be properly sanitized and/or validated to ensure that it does not contain any malicious commands.\n\n## Source Code Fix Recommendation\n\nIf the command to be executed is static and known in advance, then it can be hardcoded as in the provided code snippet. If the command needs to be constructed dynamically, then it should be done in a way that does not allow command injection. Here is an example:\n\n```python\n# BAD: allows command injection\ncommand = \"ls \" + user_input\nssh_client.exec_command(command)\n\n# GOOD: prevents command injection\ncommand = [\"ls\", user_input]\nssh_client.exec_command(' '.join(pipes.quote(arg) for arg in command))\n```\n\nIn the above example, `pipes.quote` is used to properly escape any special characters in the user input that could potentially lead to command injection.\n\n## Library Dependencies\n\nThe provided code snippet requires the following Python library:\n\n- Paramiko\n\n## References\n\n- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "tags": [
                  "B601"
                ]
              }
            },
            {
              "id": "glog-84fc41a5-d320-49c5-96db-6d9d9b62b49e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"Potential Shell Injection through Paramiko Call\" in Python refers to the potential for an attacker to inject malicious shell commands through the use of the `exec_command` function in the Paramiko library. This function is used to execute shell commands on a remote server via SSH. If the command string passed to `exec_command` is constructed using unsanitized user input, it can lead to shell injection attacks.\n\nIn the provided code snippet, the `upload_script_path_remote` variable is directly formatted into the command string. If an attacker can control the value of `upload_script_path_remote`, they could potentially execute arbitrary commands on the remote server.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid constructing shell commands using string formatting or concatenation with user-controlled input. Instead, use the built-in mechanisms provided by the library to handle command parameters.\n\n## Source Code Fix Recommendation\n\nIn the case of Paramiko, the `exec_command` function does not provide a mechanism for handling command parameters. Therefore, it is recommended to sanitize the `upload_script_path_remote` variable before using it in the command string. This can be done using the `shlex.quote` function from the Python standard library:\n\n```python\nimport shlex\n\nsanitized_path = shlex.quote(upload_script_path_remote)\nprint_ssh_out(ssh_client.exec_command(\"rm -rf {}\".format(sanitized_path)))\n```\n\n## Library Dependencies\n\nThe code example requires the following Python libraries:\n\n- Paramiko: for SSH client functionality.\n\n## References\n\n- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "tags": [
                  "B601"
                ]
              }
            },
            {
              "id": "glog-261d3d16-9309-4c0b-a021-eabf57159e6d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nPotential Shell Injection through Paramiko Call is a vulnerability that occurs when an application provides an attacker the ability to control the argument to a system call that is made to the shell. This vulnerability can allow an attacker to execute arbitrary commands on the system with the privileges of the vulnerable application.\n\nIn the provided Python code, the argument to the `exec_command` function is a static string, which does not pose a risk by itself. However, if this string were to be constructed using user-supplied input, it could potentially lead to a shell injection vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using shell commands whenever possible. If it is necessary to use shell commands, never construct command strings using user-supplied input. Instead, use library functions that allow you to pass command arguments as an array or list, which prevents shell metacharacters from being interpreted.\n\n## Source Code Fix Recommendation\n\nIf you must use the `exec_command` function with user-supplied input, sanitize the input first. Here's an example of how you might do this:\n\n```python\nimport shlex\nuser_input = get_user_input()  # This is a placeholder for your user input retrieval code\nsafe_input = shlex.quote(user_input)\nprint_ssh_out(ssh_client.exec_command(f\"ls -l {safe_input}\"))\n```\n\nIn this code, `shlex.quote` is used to safely quote a string for use as a shell token.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- Paramiko\n\n## OWASP Resources\n\n- [Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "tags": [
                  "B601"
                ]
              }
            },
            {
              "id": "glog-2a9e4f3a-134b-4137-a198-97c1b2b9cfac",
              "help": {
                "text": "",
                "markdown": "## Description\n\nPotential Shell Injection through Paramiko Call is a vulnerability that occurs when an application provides an attacker the ability to control the argument to a system call that is made to the shell. This vulnerability can allow an attacker to execute arbitrary commands on the system with the privileges of the vulnerable application.\n\nIn the provided Python code, the argument to the `exec_command` function is a static string, which does not pose a risk by itself. However, if this string were to be constructed using user-supplied input, it could potentially lead to a shell injection vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using shell commands whenever possible. If it is necessary to use shell commands, never construct command strings using user-supplied input. Instead, use library functions that allow you to pass command arguments as an array or list, which prevents shell metacharacters from being interpreted.\n\n## Source Code Fix Recommendation\n\nIf you must use the `exec_command` function with user-supplied input, sanitize the input first. Here's an example of how you might do this:\n\n```python\nimport shlex\nuser_input = get_user_input()  # This is a placeholder for your user input retrieval code\nsafe_input = shlex.quote(user_input)\nprint_ssh_out(ssh_client.exec_command(f\"ls -l {safe_input}\"))\n```\n\nIn this code, `shlex.quote` is used to safely quote a string for use as a shell token.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- Paramiko\n\n## OWASP Resources\n\n- [Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "tags": [
                  "B601"
                ]
              }
            },
            {
              "id": "glog-6c027fd6-29b6-4bb2-a1fd-99fed14d0ac2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Paramiko Call Shell Injection Vulnerability\" is a security vulnerability that occurs when an attacker is able to inject malicious shell commands into the `exec_command` function of the Paramiko SSH client in Python. This can lead to remote code execution, unauthorized access, data leakage, and other security breaches.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using user-supplied input directly in the `exec_command` function without proper sanitization and validation. User input should be treated as untrusted by default. \n\n## Source Code Fix Recommendation\n\nHere is an example of how to sanitize user input before using it in `exec_command`:\n\n```python\nimport shlex\nimport paramiko\n\nssh_client = paramiko.SSHClient()\nssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nssh_client.connect('hostname', username='username', password='password')\n\ncommand = input(\"Enter your command: \")\nsafe_command = shlex.quote(command)\n\nstdin, stdout, stderr = ssh_client.exec_command(safe_command)\n```\n\nIn this example, the `shlex.quote` function is used to sanitize the user input. This function returns a shell-escaped version of the input string, making it safe to use as a token in a shell command.\n\n## Library Dependencies\n\nThe code example requires the following Python libraries:\n\n- `paramiko`\n- `shlex`\n\n## References\n\n- [OWASP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html)\n- [CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')](https://cwe.mitre.org/data/definitions/77.html)"
              },
              "properties": {
                "tags": [
                  "B601"
                ]
              }
            },
            {
              "id": "glog-a5dafe84-3b2a-4ba1-8689-e8602834ac30",
              "help": {
                "text": "",
                "markdown": "## Description\n\nPotential Shell Injection through Paramiko Call is a vulnerability that occurs when an application provides an attacker the ability to control the argument to a system call that is made to the shell. This vulnerability can allow an attacker to execute arbitrary commands on the system with the privileges of the vulnerable application.\n\nIn the provided Python code, the argument to the `exec_command` function is a static string, which does not pose a risk by itself. However, if this string were to be constructed using user-supplied input, it could potentially lead to a shell injection vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using shell commands whenever possible. If it is necessary to use shell commands, never construct command strings using user-supplied input. Instead, use library functions that allow you to pass command arguments as an array or list, which prevents shell metacharacters from being interpreted.\n\n## Source Code Fix Recommendation\n\nIf you must use the `exec_command` function with user-supplied input, sanitize the input first. Here's an example of how you might do this:\n\n```python\nimport shlex\nuser_input = get_user_input()  # This is a placeholder for your user input retrieval code\nsafe_input = shlex.quote(user_input)\nprint_ssh_out(ssh_client.exec_command(f\"ls -l {safe_input}\"))\n```\n\nIn this code, `shlex.quote` is used to safely quote a string for use as a shell token.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- Paramiko\n\n## OWASP Resources\n\n- [Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "tags": [
                  "B601"
                ]
              }
            },
            {
              "id": "glog-8b9cc6b3-fc71-42de-9df7-f6ea00a83dba",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Auto-trust of Unknown Host Key in Paramiko Call\" vulnerability in Python programming language refers to a security flaw where the SSH client automatically trusts and adds an unknown host key to its list of known hosts. This happens when the `AutoAddPolicy()` method from the Paramiko library is used. This can lead to Man-in-the-Middle (MitM) attacks, where an attacker can intercept and possibly alter the communication between the client and the server.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using `AutoAddPolicy()`. Instead, use `RejectPolicy()` or `WarningPolicy()`. The former will reject unknown hosts, while the latter will issue a warning and reject the connection. It's also a good practice to manually manage your known hosts file and verify host keys before adding them.\n\n## Source Code Fix Recommendation\n\nReplace:\n\n```python\nssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n```\n\nWith:\n\n```python\nssh_client.set_missing_host_key_policy(paramiko.RejectPolicy())\n```\n\nOr:\n\n```python\nssh_client.set_missing_host_key_policy(paramiko.WarningPolicy())\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- Paramiko\n\n## References\n\n- [OWASP - Insecure Network Communication](https://owasp.org/www-project-mobile-top-10/2016-risks/m3-insecure-communication)\n- [CWE-295: Improper Certificate Validation](https://cwe.mitre.org/data/definitions/295.html)"
              },
              "properties": {
                "tags": [
                  "B507"
                ]
              }
            },
            {
              "id": "glog-b70bfe83-b173-4a1d-b6d8-3f1b48378141",
              "help": {
                "text": "",
                "markdown": "## Description\n\nPotential Shell Injection through Paramiko Call is a vulnerability that occurs when an application provides an attacker the ability to control the argument to a system call that is made to the shell. This vulnerability can allow an attacker to execute arbitrary commands on the system with the privileges of the vulnerable application.\n\nIn the provided Python code, the argument to the `exec_command` function is a static string, which does not pose a risk by itself. However, if this string were to be constructed using user-supplied input, it could potentially lead to a shell injection vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using shell commands whenever possible. If it is necessary to use shell commands, never construct command strings using user-supplied input. Instead, use library functions that allow you to pass command arguments as an array or list, which prevents shell metacharacters from being interpreted.\n\n## Source Code Fix Recommendation\n\nIf you must use the `exec_command` function with user-supplied input, sanitize the input first. Here's an example of how you might do this:\n\n```python\nimport shlex\nuser_input = get_user_input()  # This is a placeholder for your user input retrieval code\nsafe_input = shlex.quote(user_input)\nprint_ssh_out(ssh_client.exec_command(f\"ls -l {safe_input}\"))\n```\n\nIn this code, `shlex.quote` is used to safely quote a string for use as a shell token.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- Paramiko\n\n## OWASP Resources\n\n- [Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "tags": [
                  "B601"
                ]
              }
            },
            {
              "id": "glog-2c6f4af7-86a7-4c3b-9efb-19b1b94ca7b8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nPotential Shell Injection through Paramiko Call is a vulnerability that occurs when an application provides an attacker the ability to control the argument to a system call that is made to the Paramiko library. This vulnerability can allow an attacker to execute arbitrary commands on the system with the privileges of the vulnerable application.\n\nIn the provided code snippet, the argument to the `exec_command` function is a static string `\"pwd\"`. However, if this argument is constructed using externally controlled input, then an attacker could potentially inject arbitrary commands.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using user-controlled input to construct system commands. If it is necessary to use user-controlled input in a system command, then the input should be properly sanitized and/or validated to ensure that it does not contain any malicious commands.\n\n## Source Code Fix Recommendation\n\nIf the command to be executed is static and known in advance, then it can be hardcoded as in the provided code snippet. If the command needs to be constructed dynamically, then it should be done in a way that does not allow command injection. Here is an example:\n\n```python\n# BAD: allows command injection\ncommand = \"ls \" + user_input\nssh_client.exec_command(command)\n\n# GOOD: prevents command injection\ncommand = [\"ls\", user_input]\nssh_client.exec_command(' '.join(pipes.quote(arg) for arg in command))\n```\n\nIn the above example, `pipes.quote` is used to properly escape any special characters in the user input that could potentially lead to command injection.\n\n## Library Dependencies\n\nThe provided code snippet requires the following Python library:\n\n- Paramiko\n\n## References\n\n- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "tags": [
                  "B601"
                ]
              }
            },
            {
              "id": "glog-b98437a2-ab06-4c0b-a769-35e6e9f2cf64",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"Potential Shell Injection through Paramiko Call\" in Python refers to the potential for an attacker to inject malicious shell commands through the use of the `exec_command` function in the Paramiko library. This function is used to execute shell commands on a remote server via SSH. If the command string passed to `exec_command` is constructed using unsanitized user input, it can lead to shell injection attacks.\n\nIn the provided code snippet, the `upload_script_path_remote` variable is directly formatted into the command string. If an attacker can control the value of `upload_script_path_remote`, they could potentially execute arbitrary commands on the remote server.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid constructing shell commands using string formatting or concatenation with user-controlled input. Instead, use the built-in mechanisms provided by the library to handle command parameters.\n\n## Source Code Fix Recommendation\n\nIn the case of Paramiko, the `exec_command` function does not provide a mechanism for handling command parameters. Therefore, it is recommended to sanitize the `upload_script_path_remote` variable before using it in the command string. This can be done using the `shlex.quote` function from the Python standard library:\n\n```python\nimport shlex\n\nsanitized_path = shlex.quote(upload_script_path_remote)\nprint_ssh_out(ssh_client.exec_command(\"rm -rf {}\".format(sanitized_path)))\n```\n\n## Library Dependencies\n\nThe code example requires the following Python libraries:\n\n- Paramiko: for SSH client functionality.\n\n## References\n\n- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "tags": [
                  "B601"
                ]
              }
            },
            {
              "id": "glog-b8d5a561-6846-4da2-8cef-124633a9d779",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Paramiko Call Shell Injection Vulnerability\" in Python refers to a security flaw where an attacker can inject arbitrary shell commands that get executed on a remote server. This is possible when user-supplied input is used directly in a command that is executed on the server. In the provided code example, the `csv_file_path_remote` variable is directly used in a command without any sanitization or validation, making it a potential point of injection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using user-supplied input directly in shell commands. If it's necessary to use user input, it should be properly sanitized and validated to ensure it does not contain any malicious commands. \n\n## Source Code Fix Recommendation\n\nA safer approach would be to use the `os.path` library to handle file paths and the `os` library to handle file operations. This way, you can avoid shell command injection vulnerabilities. Here is a fixed version of the code:\n\n```python\nimport os\nimport paramiko\n\nssh_client = paramiko.SSHClient()\nssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nssh_client.connect('hostname', username='username', password='password')\n\nsftp_client = ssh_client.open_sftp()\n\ntry:\n    sftp_client.remove(csv_file_path_remote)\nexcept IOError as e:\n    print(f\"Failed to remove {csv_file_path_remote}: {str(e)}\")\n```\n\nIn this code, the `sftp_client.remove()` function is used to delete the file, which avoids the need for a shell command.\n\n## Library Dependencies\n\nThe code example requires the following Python libraries:\n\n- `paramiko`\n- `os`\n\n## References\n\n- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "tags": [
                  "B601"
                ]
              }
            },
            {
              "id": "glog-33dba3a9-f1c6-4b3c-a108-cbd33f5e94b1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Paramiko Call Shell Injection Vulnerability\" is a security vulnerability that occurs when an attacker is able to inject malicious shell commands into the `exec_command` function of the Paramiko SSH client in Python. This can lead to remote code execution, unauthorized access, data leakage, and other security breaches.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using user-supplied input directly in the `exec_command` function without proper sanitization and validation. User input should be treated as untrusted by default. \n\n## Source Code Fix Recommendation\n\nHere is an example of how to sanitize user input before using it in `exec_command`:\n\n```python\nimport shlex\nimport paramiko\n\nssh_client = paramiko.SSHClient()\nssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nssh_client.connect('hostname', username='username', password='password')\n\ncommand = input(\"Enter your command: \")\nsafe_command = shlex.quote(command)\n\nstdin, stdout, stderr = ssh_client.exec_command(safe_command)\n```\n\nIn this example, the `shlex.quote` function is used to sanitize the user input. This function returns a shell-escaped version of the input string, making it safe to use as a token in a shell command.\n\n## Library Dependencies\n\nThe code example requires the following Python libraries:\n\n- `paramiko`\n- `shlex`\n\n## References\n\n- [OWASP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html)\n- [CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')](https://cwe.mitre.org/data/definitions/77.html)"
              },
              "properties": {
                "tags": [
                  "B601"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-ab61403a-c772-4daf-b5bc-8046be1aface",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Shell=True Subprocess Call Security Vulnerability Detected\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/core/console.py"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 16,
                  "endLine": 67,
                  "endColumn": 10,
                  "snippet": {
                    "text": "        try:\n"
                  }
                },
                "contextRegion": {
                  "startLine": 70,
                  "endLine": 81,
                  "snippet": {
                    "text": "            stderr=subprocess.STDOUT,\n            shell=True,\n            universal_newlines=True,\n            bufsize=1,\n            env=env,\n        )\n\n        # Get the output of the shell command, and check for failure, and return the output.\n        try:\n            if not self.live_output:\n                outs, errs = proc.communicate(timeout=timeout)\n            else:\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "HIGH",
            "issue_confidence": "HIGH"
          }
        },
        {
          "ruleId": "glog-16e48097-92fe-4d3a-ba06-732f6e407b95",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "SQL Injection Vulnerability via String-Based Query Construction"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/db/database.py"
                },
                "region": {
                  "startLine": 199,
                  "startColumn": 9,
                  "endLine": 200,
                  "endColumn": 24,
                  "snippet": {
                    "text": "        \"UPDATE {} \\\n"
                  }
                },
                "contextRegion": {
                  "startLine": 198,
                  "endLine": 202,
                  "snippet": {
                    "text": "    ENGINE.execute(\n        \"UPDATE {} \\\n        SET \\\n        {} = TRIM({});\".format(\n            DB_TABLE.__tablename__, col_name, col_name\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-f6dbf333-97e1-4884-a2e9-9c6d92e5e6ec",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "SQL Injection Vulnerability via String-Based Query Construction"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/db/database_functions.py"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 9,
                  "endLine": 57,
                  "endColumn": 10,
                  "snippet": {
                    "text": "        \"SELECT * FROM dlm_table \\\n"
                  }
                },
                "contextRegion": {
                  "startLine": 55,
                  "endLine": 60,
                  "snippet": {
                    "text": "    matching_entries = ENGINE.execute(\n        \"SELECT * FROM dlm_table \\\n        WHERE model='{}' \\\n        AND gpu_architecture='{}' \\\n        \".format(\n            recent_entry[\"model\"], \n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-113fb92e-cf17-489c-bbf4-7f104686cece",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Shell=True in Subprocess Call Security Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/scripts/common/pre_scripts/rocEnvTool/console.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 14,
                  "endLine": 19,
                  "endColumn": 160,
                  "snippet": {
                    "text": "      proc = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True, universal_newlines=True, bufsize=1)\n"
                  }
                },
                "contextRegion": {
                  "startLine": 18,
                  "endLine": 20,
                  "snippet": {
                    "text": "          print(\"> \" + command, flush=True)\n      proc = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True, universal_newlines=True, bufsize=1)\n      try:\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "HIGH",
            "issue_confidence": "HIGH"
          }
        },
        {
          "ruleId": "glog-ad9e67d9-98bf-4554-88c6-759f813e2693",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Shell=True Subprocess Call Security Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/scripts/common/tools/gpu_info_profiler.py"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 5,
                  "endLine": 59,
                  "endColumn": 82,
                  "snippet": {
                    "text": "    subprocess.run(commandstring, shell=True, check=True, executable=\"/bin/bash\")\n"
                  }
                },
                "contextRegion": {
                  "startLine": 58,
                  "endLine": 60,
                  "snippet": {
                    "text": "    logging.debug(commandstring)\n    subprocess.run(commandstring, shell=True, check=True, executable=\"/bin/bash\")\n\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "HIGH",
            "issue_confidence": "HIGH"
          }
        },
        {
          "ruleId": "glog-eee2b7af-c788-40d9-87a2-99813830f994",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Shell=True Subprocess Call Security Vulnerability Detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/scripts/common/tools/gpu_info_profiler.py"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 5,
                  "endLine": 79,
                  "endColumn": 76,
                  "snippet": {
                    "text": "    subprocess.run(command, shell=True, check=True, executable=\"/bin/bash\")\n"
                  }
                },
                "contextRegion": {
                  "startLine": 78,
                  "endLine": 80,
                  "snippet": {
                    "text": "    logging.debug(command)\n    subprocess.run(command, shell=True, check=True, executable=\"/bin/bash\")\n\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "HIGH",
            "issue_confidence": "HIGH"
          }
        },
        {
          "ruleId": "glog-bdcb1a80-10fe-45e4-a3c4-ac9e959a982c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Shell=True Subprocess Call Security Vulnerability Detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/scripts/common/tools/gpu_info_profiler.py"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 5,
                  "endLine": 99,
                  "endColumn": 76,
                  "snippet": {
                    "text": "    subprocess.run(command, shell=True, check=True, executable=\"/bin/bash\")\n"
                  }
                },
                "contextRegion": {
                  "startLine": 98,
                  "endLine": 100,
                  "snippet": {
                    "text": "    logging.debug(command)\n    subprocess.run(command, shell=True, check=True, executable=\"/bin/bash\")\n\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "HIGH",
            "issue_confidence": "HIGH"
          }
        },
        {
          "ruleId": "glog-432f64f2-5069-47f9-8b07-21a5b8a2cfbf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "SQL Injection Vulnerability via String-Based Query Construction"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/db/database.py"
                },
                "region": {
                  "startLine": 222,
                  "startColumn": 9,
                  "endLine": 223,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        \"SELECT `COLUMN_NAME` \\\n"
                  }
                },
                "contextRegion": {
                  "startLine": 221,
                  "endLine": 226,
                  "snippet": {
                    "text": "    result = ENGINE.execute(\n        \"SELECT `COLUMN_NAME` \\\n            FROM `INFORMATION_SCHEMA`.`COLUMNS` \\\n                WHERE `TABLE_SCHEMA`='{}' \\\n                AND `TABLE_NAME`='{}'\".format(db_name, DB_TABLE.__tablename__)\n    )\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-980ad1cc-f349-4f81-abdb-8ee3b924a59e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "SQL Injection Vulnerability via String-Based Query Construction"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/db/database.py"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 13,
                  "endLine": 148,
                  "endColumn": 58,
                  "snippet": {
                    "text": "            \"SELECT * FROM {} \\\n"
                  }
                },
                "contextRegion": {
                  "startLine": 146,
                  "endLine": 150,
                  "snippet": {
                    "text": "        result = ENGINE.execute(\n            \"SELECT * FROM {} \\\n                WHERE {}.created_date= \\\n                    (SELECT MAX(created_date) FROM {}) ;\".format(DB_TABLE.__tablename__)\n        )\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-8f506d5f-a59a-4d6a-9ed5-08e67f577297",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Auto-trust of Unknown Host Key in Paramiko Call\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/tools/create_table_db.py"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 9,
                  "endLine": 148,
                  "endColumn": 73,
                  "snippet": {
                    "text": "        ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n"
                  }
                },
                "contextRegion": {
                  "startLine": 147,
                  "endLine": 149,
                  "snippet": {
                    "text": "        ssh_client = paramiko.SSHClient()\n        ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        ssh_client.load_system_host_keys()\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "HIGH",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-dc03b5b1-edbf-4d16-b583-f47842091177",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential Shell Injection through Paramiko Call\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/tools/create_table_db.py"
                },
                "region": {
                  "startLine": 173,
                  "startColumn": 23,
                  "endLine": 173,
                  "endColumn": 53,
                  "snippet": {
                    "text": "        print_ssh_out(ssh_client.exec_command(\"pwd\"))\n"
                  }
                },
                "contextRegion": {
                  "startLine": 172,
                  "endLine": 174,
                  "snippet": {
                    "text": "        # print remote dir layout\n        print_ssh_out(ssh_client.exec_command(\"pwd\"))\n        print_ssh_out(ssh_client.exec_command(\"ls -l\"))\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-84fc41a5-d320-49c5-96db-6d9d9b62b49e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential Shell Injection through Paramiko Call\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/tools/create_table_db.py"
                },
                "region": {
                  "startLine": 181,
                  "startColumn": 23,
                  "endLine": 181,
                  "endColumn": 93,
                  "snippet": {
                    "text": "        print_ssh_out(ssh_client.exec_command(\"rm -rf {}\".format(upload_script_path_remote)))\n"
                  }
                },
                "contextRegion": {
                  "startLine": 180,
                  "endLine": 182,
                  "snippet": {
                    "text": "        # clean up previous uploads\n        print_ssh_out(ssh_client.exec_command(\"rm -rf {}\".format(upload_script_path_remote)))\n        print_ssh_out(ssh_client.exec_command(\"ls -l\"))       \n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-261d3d16-9309-4c0b-a021-eabf57159e6d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential Shell Injection through Paramiko Call\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/tools/create_table_db.py"
                },
                "region": {
                  "startLine": 174,
                  "startColumn": 23,
                  "endLine": 174,
                  "endColumn": 55,
                  "snippet": {
                    "text": "        print_ssh_out(ssh_client.exec_command(\"ls -l\"))\n"
                  }
                },
                "contextRegion": {
                  "startLine": 173,
                  "endLine": 175,
                  "snippet": {
                    "text": "        print_ssh_out(ssh_client.exec_command(\"pwd\"))\n        print_ssh_out(ssh_client.exec_command(\"ls -l\"))\n\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-2a9e4f3a-134b-4137-a198-97c1b2b9cfac",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential Shell Injection through Paramiko Call\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/tools/create_table_db.py"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 23,
                  "endLine": 182,
                  "endColumn": 55,
                  "snippet": {
                    "text": "        print_ssh_out(ssh_client.exec_command(\"ls -l\"))       \n"
                  }
                },
                "contextRegion": {
                  "startLine": 181,
                  "endLine": 183,
                  "snippet": {
                    "text": "        print_ssh_out(ssh_client.exec_command(\"rm -rf {}\".format(upload_script_path_remote)))\n        print_ssh_out(ssh_client.exec_command(\"ls -l\"))       \n\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-6c027fd6-29b6-4bb2-a1fd-99fed14d0ac2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Paramiko Call Shell Injection Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/tools/create_table_db.py"
                },
                "region": {
                  "startLine": 195,
                  "startColumn": 13,
                  "endLine": 196,
                  "endColumn": 14,
                  "snippet": {
                    "text": "            ssh_client.exec_command(\n"
                  }
                },
                "contextRegion": {
                  "startLine": 194,
                  "endLine": 204,
                  "snippet": {
                    "text": "        print_ssh_out(\n            ssh_client.exec_command(\n                \"TUNA_DB_USER_NAME={} TUNA_DB_USER_PASSWORD={} TUNA_DB_NAME={} TUNA_DB_HOSTNAME={} python3 {}\".format(\n                    self.user_name,\n                    self.user_password,\n                    self.db_name,\n                    self.db_hostname,\n                    main_script,\n                )\n            )\n        )\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-a5dafe84-3b2a-4ba1-8689-e8602834ac30",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential Shell Injection through Paramiko Call\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/tools/create_table_db.py"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 23,
                  "endLine": 207,
                  "endColumn": 55,
                  "snippet": {
                    "text": "        print_ssh_out(ssh_client.exec_command(\"ls -l\"))\n"
                  }
                },
                "contextRegion": {
                  "startLine": 206,
                  "endLine": 208,
                  "snippet": {
                    "text": "        # print remote dir after upload\n        print_ssh_out(ssh_client.exec_command(\"ls -l\"))\n\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-8b9cc6b3-fc71-42de-9df7-f6ea00a83dba",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Auto-trust of Unknown Host Key in Paramiko Call\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/tools/update_table_db.py"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 9,
                  "endLine": 150,
                  "endColumn": 73,
                  "snippet": {
                    "text": "        ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n"
                  }
                },
                "contextRegion": {
                  "startLine": 149,
                  "endLine": 151,
                  "snippet": {
                    "text": "        ssh_client = paramiko.SSHClient()\n        ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        ssh_client.load_system_host_keys()\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "HIGH",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-b70bfe83-b173-4a1d-b6d8-3f1b48378141",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential Shell Injection through Paramiko Call\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/tools/update_table_db.py"
                },
                "region": {
                  "startLine": 176,
                  "startColumn": 23,
                  "endLine": 176,
                  "endColumn": 55,
                  "snippet": {
                    "text": "        print_ssh_out(ssh_client.exec_command(\"ls -l\"))\n"
                  }
                },
                "contextRegion": {
                  "startLine": 175,
                  "endLine": 177,
                  "snippet": {
                    "text": "        print_ssh_out(ssh_client.exec_command(\"pwd\"))\n        print_ssh_out(ssh_client.exec_command(\"ls -l\"))\n\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-2c6f4af7-86a7-4c3b-9efb-19b1b94ca7b8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential Shell Injection through Paramiko Call\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/tools/update_table_db.py"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 23,
                  "endLine": 175,
                  "endColumn": 53,
                  "snippet": {
                    "text": "        print_ssh_out(ssh_client.exec_command(\"pwd\"))\n"
                  }
                },
                "contextRegion": {
                  "startLine": 174,
                  "endLine": 176,
                  "snippet": {
                    "text": "        # print remote dir layout\n        print_ssh_out(ssh_client.exec_command(\"pwd\"))\n        print_ssh_out(ssh_client.exec_command(\"ls -l\"))\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-b98437a2-ab06-4c0b-a769-35e6e9f2cf64",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential Shell Injection through Paramiko Call\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/tools/update_table_db.py"
                },
                "region": {
                  "startLine": 185,
                  "startColumn": 23,
                  "endLine": 185,
                  "endColumn": 93,
                  "snippet": {
                    "text": "        print_ssh_out(ssh_client.exec_command(\"rm -rf {}\".format(upload_script_path_remote)))\n"
                  }
                },
                "contextRegion": {
                  "startLine": 184,
                  "endLine": 186,
                  "snippet": {
                    "text": "        # clean up previous uploads\n        print_ssh_out(ssh_client.exec_command(\"rm -rf {}\".format(upload_script_path_remote)))\n        print_ssh_out(ssh_client.exec_command(\"rm -rf {}\".format(csv_file_path_remote)))\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-b8d5a561-6846-4da2-8cef-124633a9d779",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Paramiko Call Shell Injection Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/tools/update_table_db.py"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 23,
                  "endLine": 186,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        print_ssh_out(ssh_client.exec_command(\"rm -rf {}\".format(csv_file_path_remote)))\n"
                  }
                },
                "contextRegion": {
                  "startLine": 185,
                  "endLine": 187,
                  "snippet": {
                    "text": "        print_ssh_out(ssh_client.exec_command(\"rm -rf {}\".format(upload_script_path_remote)))\n        print_ssh_out(ssh_client.exec_command(\"rm -rf {}\".format(csv_file_path_remote)))\n\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        },
        {
          "ruleId": "glog-33dba3a9-f1c6-4b3c-a108-cbd33f5e94b1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Paramiko Call Shell Injection Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/madengine/tools/update_table_db.py"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 13,
                  "endLine": 208,
                  "endColumn": 14,
                  "snippet": {
                    "text": "            ssh_client.exec_command(\n"
                  }
                },
                "contextRegion": {
                  "startLine": 206,
                  "endLine": 217,
                  "snippet": {
                    "text": "        print_ssh_out(\n            ssh_client.exec_command(\n                \"TUNA_DB_USER_NAME={} TUNA_DB_USER_PASSWORD={} TUNA_DB_NAME={} TUNA_DB_HOSTNAME={} python3 {} --csv-file-path {}\".format(\n                    self.user_name,\n                    self.user_password,\n                    self.db_name,\n                    self.db_hostname,\n                    main_script,\n                    csv_file_path_remote,\n                )\n            )\n        )\n"
                  }
                }
              }
            }
          ],
          "properties": {
            "issue_severity": "MEDIUM",
            "issue_confidence": "MEDIUM"
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}